<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <!-- The above 3 meta tags *must* come first in the head;
         any other head content must come *after* these tags -->

    <!-- Icon to use on the browser bar -->
    <link rel="icon" href="calendar/images/web-icon.png">

    <!-- Bootstrap core CSS -->
    <link href="calendar/bootstrap/css/bootstrap.min.css" rel="stylesheet">

    <!-- Skeleton CSS -->
    <link rel="stylesheet" href="calendar/Skeleton/css/normalize.css">
    <link rel="stylesheet" href="calendar/Skeleton/css/skeleton.css">
    <link rel="stylesheet" href="calendar/css/skeleton-modifications.css">

    <!-- IE10 viewport hack for Surface/desktop Windows 8 bug -->
    <link href="calendar/bootstrap3-ie10-viewport-bug-workaround/ie10-viewport-bug-workaround.css" rel="stylesheet">

    <!-- Fonts -->
    <link href='calendar/fonts/raleway.css' rel='stylesheet' type='text/css'>

    <!-- Ace Code Editor - https://ace.c9.io/ -->
    <script type="text/javascript" src="calendar/ace-builds/src-noconflict/ace.js" charset="utf-8">
    </script>

    <!-- Chart.js - http://www.chartjs.org -->
    <script type="text/javascript" src="calendar/chartjs/Chart.bundle.min.js" charset="utf-8">
    </script>

    <!-- To support challenge/response authentication within course notes-->
        <script type="text/javascript">
      var nonce = "db7b157759f74d01bc7adacdc5d261bdc3a8eb063aa71e6845eb49de39ba5ea3";
    </script>
    <script type="text/javascript" src="calendar/js/sha256.js"></script>
    
    <!-- Styles for the submission System -->
    <link href="calendar/css/calendar-default.css" rel="stylesheet">

    <!-- HTML5 shim and Respond.js for IE8 support of HTML5 elements and media queries -->
    <!--[if lt IE 9]>
      <script src="https://oss.maxcdn.com/html5shiv/3.7.2/html5shiv.min.js"></script>
      <script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
    <![endif]-->

    <!-- MathJax -->
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ["\\(","\\)"] ],
          processEscapes: true
        }
      });
    </script>
    <script type="text/javascript" src="../../ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML">
    </script>

    <!-- Highlight.js -->
    <link rel="stylesheet" href="calendar/highlight/styles/color-brewer.css">
    <script src='calendar/highlight/highlight.pack.js'></script>
    <script>hljs.initHighlightingOnLoad();</script>

    <!-- Font-Awesome -->
    <link rel="stylesheet" type="text/css" href="calendar/Font-Awesome/css/font-awesome.min.css">

    <!-- Datatables -->
    <link rel="stylesheet" type="text/css" href="calendar/datatables.net/datatables.min.css">

    <!-- Printing -->
    <link rel="stylesheet" type="text/css" media="print" href="calendar/css/calendar-print.css">

    <!-- Custom CSS based on user preferences -->
    <link href='docs/sy110_cdrD.css' rel='stylesheet'>
      
      
    <!-- Custom JavaScript based on user preferences -->

    <!-- Bootstrap core JavaScript
    ================================================== -->
    <!-- Placed at the end of the document so the pages load faster -->
    <script src="calendar/jquery/js/jquery-3.3.1.min.js"></script>
    <script src="calendar/bootstrap/js/bootstrap.min.js"></script>
    <!-- IE10 viewport hack for Surface/desktop Windows 8 bug -->
    <script src="calendar/bootstrap3-ie10-viewport-bug-workaround/ie10-viewport-bug-workaround.js"></script>
    <!-- DataTables -->
    <script type="text/javascript" src="calendar/datatables.net/datatables.min.js"></script>

  <title>SY110 (Fall 2020)</title>

  </head>
  <body>

    <!-- Fixed navbar -->
    <nav class="navbar navbar-default navbar-fixed-top">
      <div class="container">
        <div class="navbar-header">
          <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false" aria-controls="navbar">
            <span class="sr-only">Toggle navigation</span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </button>
          <!--
            <a class="navbar-brand" href="#">
              <img alt="Navbar!" src="css/images/web-icon.png" width="24">
            </a>
          -->
        </div>
        <div id="navbar" class="navbar-collapse collapse">
          <ul class="nav navbar-nav">

            <li><a href="calendar.php.html?load=home">
                SY110 - Introduction to Cyber Security</a></li>

            
            <li><a title="Calendar" href="calendar.php-1.html?show=calendar_display">
                <span class="glyphicon glyphicon-calendar" aria-hidden="true"></span>
                </a></li>

            <li><a title="Resources" href="calendar.php-2.html?load=resources">
                <span class="glyphicon glyphicon-briefcase" aria-hidden="true"></span>
                </a></li>

            <li><a title="Information" href="calendar.php-3.html?load=policy">
                <span class="glyphicon glyphicon-info-sign" aria-hidden="true"></span>
                </a></li>

        
        
          </ul>

        
          <ul class="nav navbar-nav navbar-right">
            <li class="dropdown">
<a href="#" title="View files associated with lecture" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-haspopup="true" aria-expanded="false">
Stack - Transport Layer
</a>
<ul class="dropdown-menu  scrollable-menu">
<li class="dropdown-header">Options</li>
<li><form method="post" class="navbar-form navbar-left" role="search" target="_blank">
  <div class="input-group">
    <input type="hidden" class="form-control" name="print" id="print">
    <div class="input-group-btn">
        <button class="btn btn-default" type="submit"><i class="glyphicon glyphicon-print"></i> Print</button>
    </div>
  </div>
</form></li>
<li><form method="get" class="navbar-form navbar-left" role="search">
  <div class="input-group">
    <input type="hidden" name="show" value="calendar_search">
    <input type="text" class="form-control" placeholder="Search" name="search" id="search">
    <div class="input-group-btn">
        <button class="btn btn-default" type="submit"><i class="glyphicon glyphicon-search"></i></button>
    </div>
  </div>
</form></li>
<li><form method="post" class="navbar-form navbar-left" role="search" onsubmit="return hashPassword()">
  <div class="input-group">
    <input type="password" class="form-control" placeholder="Password" name="password" id="password">
    <div class="input-group-btn">
        <button class="btn btn-default" type="submit"><i class="glyphicon glyphicon-lock"></i></button>
    </div>
</div>
</form></li>
</ul>
</li>
            <li class="dropdown">
              <a href="#" title="Select class" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-haspopup="true" aria-expanded="false">
                <span class="glyphicon glyphicon-apple" aria-hidden="true"></span>
                Class<span class="caret"></span></a>
              <ul class="dropdown-menu  scrollable-menu">
                <li><a href='calendar.php-4.html?type=class&event=1'>1 - Intro to the Cyber Domain</a></li>
<li><a href='calendar.php-5.html?type=class&event=2'>2 - Aspects and Pillars of Cyber Security</a></li>
<li><a href='calendar.php-6.html?type=class&event=3'>3 - Computer Architecture</a></li>
<li><a href='calendar.php-7.html?type=class&event=4'>4 - Risk And Vulnerabilities</a></li>
<li><a href='calendar.php-8.html?type=class&event=5'>5 - Policy And Law</a></li>
<li><a href='calendar.php-9.html?type=class&event=6'>6 - Bits And Bytes And Files</a></li>
<li><a href='calendar.php-10.html?type=class&event=7'>7 - OS-File Systems</a></li>
<li><a href='calendar.php-11.html?type=class&event=8'>8 - OS-Permissions, Shell, And Remote Access</a></li>
<li><a href='calendar.php-12.html?type=class&event=9'>9 - Web And HTML</a></li>
<li><a href='calendar.php-13.html?type=class&event=10'>10 - JavaScript - Overview</a></li>
<li><a href='calendar.php-14.html?type=class&event=11'>11 - Vulnerabilities and Malware</a></li>
<li><a href='calendar.php-15.html?type=class&event=12'>12 - Cyberspace as a Human Domain</a></li>
<li><a href='calendar.php-16.html?type=class&event=13'>13 - Client-Side Scripting: Part One</a></li>
<li><a href='calendar.php-17.html?type=class&event=14'>14 - Client-Side Scripting: Part Two</a></li>
<li><a href='calendar.php-18.html?type=class&event=15'>15 - Server-Side Scripting</a></li>
<li><a href='calendar.php-19.html?type=class&event=16'>16 - Human Factors in Cyber Operations</a></li>
<li><a href='calendar.php-20.html?type=class&event=17'>17 - Stack-Intro and Physical Layer</a></li>
<li><a href='calendar.php-21.html?type=class&event=18'>18 - Stack - Data Link Layer</a></li>
<li><a href='calendar.php-22.html?type=class&event=19'>19 - Stack - Network Layer</a></li>
<li><a href='calendar.php-23.html?type=class&event=20'><font color='black'><b>20 - Stack - Transport Layer</b></font></a></li>
<li><a href='calendar.php-24.html?type=class&event=21'>21 - Stack - Application Layer</a></li>
<li><a href='calendar.php-25.html?type=class&event=22'>22 - Wireless</a></li>
<li><a href='calendar.php-26.html?type=class&event=23'>23 - Network Security Appliances and Firewalls</a></li>
<li><a href='calendar.php-27.html?type=class&event=24'>24 - Symmetric Encryption</a></li>
<li><a href='calendar.php-28.html?type=class&event=25'>25 - Asymmetric Encryption</a></li>
<li><a href='calendar.php-29.html?type=class&event=26'>26 - Steganography</a></li>
<li><a href='calendar.php-30.html?type=class&event=27'>27 - Digital Forensics</a></li>
<li><a href='calendar.php-31.html?type=class&event=28'>28 - Cyber Recon</a></li>
<li><a href='calendar.php-32.html?type=class&event=29'>29 - Attackers And Defenders</a></li>
<li><a href='calendar.php-33.html?type=class&event=30'>30 - Cyber Attack</a></li>
<li><a href='calendar.php-34.html?type=class&event=31'>31 - Cyber Defense</a></li>
              </ul>
            </li>
                        <li class="dropdown">
              <a href="#" title="Select lab" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-haspopup="true" aria-expanded="false">
                <span class="glyphicon glyphicon-knight" aria-hidden="true"></span>
                Lab<span class="caret"></span></a>
              <ul class="dropdown-menu  scrollable-menu">
                <li><a href='calendar.php-35.html?type=lab&event=1'>1 - Computer Architecture And Supply Chain</a></li>
<li><a href='calendar.php-36.html?type=lab&event=2'>2 - Windows-Unix Shell And Command Line</a></li>
<li><a href='calendar.php-37.html?type=lab&event=3'>3 - Introduction to Build a Website</a></li>
<li><a href='calendar.php-38.html?type=lab&event=4'>4 - Injection Attacks and XSS</a></li>
<li><a href='calendar.php-39.html?type=lab&event=5'>5 - LAN-WLAN</a></li>
<li><a href='calendar.php-40.html?type=lab&event=6'>6 - Hashing And Passwords</a></li>
<li><a href='calendar.php-41.html?type=lab&event=7'>7 - Digital Certificates</a></li>
<li><a href='calendar.php-42.html?type=lab&event=8'>8 - Digital Forensics</a></li>
<li><a href='calendar.php-43.html?type=lab&event=9'>9 - Cyber Recon</a></li>
<li><a href='calendar.php-44.html?type=lab&event=10'>10 - Cyber Attack</a></li>
<li><a href='calendar.php-45.html?type=lab&event=11'>11 - Cyber Defense</a></li>
<li><a title='Material not online at this time' href='#'><span style='color=#AAAAAA'>12 - _archive</span></a></li>
              </ul>
            </li>
            
          </ul>
        </div><!--/.nav-collapse -->
      </div>
    </nav>

  <!-- End TopBar and CSS Stuff! -->
<!-- Begin providing the contents of the page -->
<div class="container">
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8">
    <title>BRAND: Transport Layer</title>

    <script type="text/javascript">
      var courseSection="Cyber Battlefield";
      var firstLecture="crsIntro";
      var prevLecture="netNet";
      var nextLecture="netApp";
      var lastLecture="finalExam";
    </script>
  </head>
  <body>

    <div class="noScreen">
      <br> 
      </br>
      <h1>Stack-Transport Layer</h1>
    </div>

    <div class="learnObjs">
      <h2>Learning Outcomes</h2>
      <p>
        After completing these activities you should be able to:
      </p>
      <ul>
        <li>Describe terms associated with the Transport Layer: UDP datagram, TCP segment, and port</li>
        <li>Explain the purpose of the following protocols: TCP, UDP</li>
        <li>Explain the problems that the Transport Layer protocols above handle; i.e. the services the Transport Layer protocols provide</li>
        <li>Explain the problems that the Transport Layer protocols above do not handle; i.e. the issues that other layers need to address</li>
        <li>Explain the concept of Network Address Translation</li>
      </ul>
    </div>
    <br>
    <div id="discussion">
      <h2>Discussion</h2>
      <div>
        <h3>Introduction to the Transport Layer</h3>
        <p>
          Up to this point, as we have been working up the TCP/IP Stack we have discussed how data is passed between hosts within a local network, and across the Internet.
          But, what about programs?
          How does your web browser fit into the system?
          After all, you know that your web browser is certainly communicating via the Internet.
          Well, that is where the Transport Layer comes in; the Transport Layer connects a process on one host to a process on another host.
          Remember that a <a href="calendar.php-76.html?load=glossary#P">process</a> is just a program in execution.
          Using an example, the Transport Layer will connect a web browser process on Alice's host to a web server process on Bob's web server.
        </p>
      </div>
      <div>
        <h3>Transport Layer Basics</h3>
        <p>
          <strong>Datagram or Segment</strong>.
          A message at the Transport Layer is called a <em>datagram</em> or a <em>segment</em> depending on what protocol is in use. We will learn more about the Transport Layer protocols later in this lesson.
          Beyond connecting processes, Transport Layer protocols start the process of breaking arbitrary length Application Layer messages into smaller pieces for sending across networks.
          For example, you're on your phone and you want to download and install the latest social messaging app GipGak.
          The action of initiating the download is your request from the Application Layer, but the GipGak app is over 50MB in size, while most packets are 1500 Bytes in size.
          At the Application, Layer the app store sends the single 50MB file, but the Transport starts to break that single large message into smaller datagrams that can traverse the Internet.
          The Transport Layer is also the start of the encapsulation process on the sending end in the TCP/IP Stack, and conversely the end of the de-encapsulation process on the receiving end.
        </p>
        <p>
          <strong>Ports</strong>.
          An <a href="calendar.php-76.html?load=glossary#I">IP address</a> identifies what <em>host</em> we want our data to go to, but not which of the many <em>processes</em> executing on the host we want that data to go to.
          If we were to make an analogy to telephone traffic, it's like calling a big office: the phone number gets you to the office, but you need something extra &mdash; an extension &mdash; to identify which specific phone in the office you're trying to place a call to.
          At the Transport, Layer a <a href="calendar.php-76.html?load=glossary#P">port</a> takes the role of the office phone number extension for networked communications.
          A port number identifies the process on the host communicating.
          Just like the Data Link Layer and Network Layer addresses, for each networked communication there is a source port and a destination port.
          The source port identifies the process communicating on the source host, and the destination port identifies the process communicating on the destination host.
        </p>
        <p>
          A port number is a 16-bit non-negative number, which means it's in the range 0&mdash;2<sup>16</sup>-1 = 65535.
          You might have noticed that a port is much smaller than a MAC address or an IP address, well there's some rationale behind that.
          Each network interface has a unique MAC address, and MAC addresses are allocated based on the manufacturer; hardware manufacturers are assigned large blocks of MAC addresses for the hardware they make.
          If you were a hardware vendor, would you want to be able to produce and sell a small number or large number of devices?
          Obviously a large number vice a small number.
          Additionally, having a large address allows new networking technologies to operate using the same concepts; e.g. Wi-Fi, and Bluetooth both adopted the 48-bit MAC address from Ethernet.
          Obviously we need a large number (32-bit for IPv4, or 128-bit for IPv6) in order to uniquely identify all the hosts connected to the global Internet.
          But how big does a port number need to be?
          Is 16-bits enough?
          Well, how much multitasking do you like to do?
          Better yet, how much multitasking do you think you can do?
          Can you manage 65 thousand processes all running at the same time?
          In practice, 16-bits to represent the processes communicating on a host has not been an issue.
        </p>
        <div class="annotation">
          Shell commands <a href="calendar.php-74.html?key=3a50af6a3f71ddff08be91e84d7f272573dbc4b1&type=resources&event=1">resources</a>.
          <code class="cmd">netstat</code> requires an <em>Administrator</em> shell.
        </div>
        <p>
          <strong><code class="cmd">netstat</code></strong>.
          There's a utility called <a href="calendar.php-76.html?load=glossary#N"><code class="cmd">netstat</code></a> that shows you what port (or Application Layer protocol) combinations are currently in use on your machine.
          <code class="cmd">netstat</code> is a <a href="calendar.php-76.html?load=glossary#S">shell</a> utility on both Windows and UNIX.
          A sample <code class="cmd">netstat</code> output on Windows might include an entry like this:
        </p>
        <pre>
Active Connections

  Proto  Local Address           Foreign Address         State
  ...
  TCP    10.53.33.254:60503      74.125.228.85:443       ESTABLISHED
  ...</pre>
        <p>
          What this tells us is that there is an established connection between the local host (<code>10.53.33.254</code>) on port <code>60503</code> and the remote host (<codde>74.125.228.85 on its port <code>443</code>.
          The <em>Proto</em> in the code listing above is TCP which stands for Transport Control Protocol, we will look at TCP later in this discussion.
          The <em>Local Address</em> includes one piece of information that you should recognize, the dotted-quad of the local host's IPv4 address.
          The second number, the number after the colon, is the local port that the process on the local host is using for the communications.
          It is common to write the combination of an IP address and port with a colon ( <code>:</code> ) separating the two numbers.
          The <em>Foreign Address</em> represents the remote host's IP address and port.
          The ESTABLISHED state means that the connection is established; i.e. that the hosts are communicating.
        </codde></p>
        <p>
          You can view all server processes running on your host by name and process ID by running <code class="cmd">netstat</code> with the following options in an Administrator shell:
        </p>
        <pre>
<span class="cmd">netstat</span> <span class="opt">-bno</span>

Active Connections

  Proto  Local Address    Foreign Address   State      PID
  TCP    0.0.0.0:135      0.0.0.0:0         LISTENING  900  RpcSs [svchost.exe]
  TCP    0.0.0.0:3389     0.0.0.0:0         LISTENING 1448  CryptSvc [svchost.exe]
  TCP    0.0.0.0:49152    0.0.0.0:0         LISTENING  544  [wininit.exe]
  TCP    0.0.0.0:49376    0.0.0.0:0         LISTENING  608  [services.exe]
  UDP    0.0.0.0:68       0.0.0.0:0         LISTENING  988  Dhcp [svchost.exe]
  ...</pre>
        <p>
          The <code>0.0.0.0</code> IP address indicates that the local host is listening on any of its IP addresses, remember hosts can have multiple network devices, and therefore can have multiple IP addresses.
          Notice that each of the processes listening (State LISTENING) are listening on a specific port; i.e. even though the host is listening on all IP addresses, a process listens on a specific port.
          Since the processes are listening for incoming communications, they are considered <em>server</em> processes; in networked communications, the process that is listening for incoming communications is the server process.
          As server processes, they are waiting for an incoming communication from a client process on a remote host.
          Once a client process on a remote host sends a message to the server host, the connections would switch to ESTABLISHED as in the first code listing.
        </p>
        <p>
          Now, we can figure out which network services are running on a <a href="calendar.php-76.html?load=glossary#C">computer</a>.
          This is a big deal when it comes to assessing a computer's risk for intrusion.
          Think of it this way, if you wanted to protect your home from intruders, then you would want to know where all of the possible entrances are so that you could secure or seal them.
          The same notion applies to processes providing network services on computers, fewer running services (and hence, fewer open ports) is better (more secure) than more running services.
          Unnecessary services should be stopped and removed from computers to make them more secure from network based attacks.
        </p>
      </div>
      <div>
        <h3>User Datagram Protocol (UDP) - <a href="../../html/rfc768.html">Request For Comment (RFC) 768</a></h3>
        <p>
          There are two protocols that dominate, usage wise, the Transport Layer on the Internet, we will look at both of them.
          We will first look at the User Datagram Protocol (UDP). A message using the UDP protocol is called a datagram. According to the <a href="../../html/rfc1594.html">RFC 1594</a>, a datagram is "a self-contained, independent entity of data carrying sufficient information to be routed from the source to the destination computer without reliance on earlier exchanges between this source and destination computer and the transporting network."
        </p>
        <p>
          UDP is a bare bones protocol and doesn't really provide more services than what the underlying Network Layer and Data Link Layer provide.
          UDP can detect errors in the UDP header information, similar to the error detecting provided by IPv4 at the Network Layer.
          Like IPv4, UDP is unreliable; that is datagrams may get dropped along the way, or datagrams may arrive out of order.
          UDP is said to be a <em>connectionless</em> protocol.
          Beyond, the unreliable communication concern, connectionless means that to UDP each datagram stands on its own, much like the thank you letter you sent to grandma for the cookies.
          To UDP multiple datagrams between two communicating hosts are all treated as separate communications.
          Another way to put this is that UDP datagrams are fire and forget to UDP.
          If the Application Layer wants reliable communications, then the Application needs to solve that problem.
          One service UDP does provide is breaking large messages from the Application Layer down into small datagrams that can traverse the Internet.
        </p>
        <p>
          So, you are probably asking your self one, maybe two questions at this point.
          The first is when are we going to get a protocol that does provide reliable communications?
          The next question is, if there is a protocol that provides reliable communications, then why don't we just use that one all the time?
          Both questions are great questions, we will cover the question about reliable communications in a minute.
          First, we will tackle the "why" of using UDP if there is a protocol that provides reliable communications.
          The answer is fairly simple ... overhead.
        </p>
        <p>
          By not adding on services to what the layers lower in the TCP/IP Stack provide UDP avoids overhead on the sending and receiving end hosts.
          Providing services requires resources such as CPU, and RAM.
          By not adding on lots of services, UDP significantly reduces the resources required by the hosts.
          We will look at two specific examples of Application Layer protocols that specifically use UDP because it is connectionless, and has low overhead.
        </p>
      </div>
      <div>
        <h3>Transport Control Protocol (TCP) - <a href="../../html/rfc793.html">RFC 793</a></h3>
        <p>
          The other Transport Layer protocol that is commonly used on the Internet is Transport Control Protocol (TCP). TCP messages are commonly called TCP segments. This is because the message will arrive to the end user in segments and will require the end user to piece these segments back together to construct the full message.
          If you have been waiting for reliable connections, then wait no more, TCP is the Transport Layer Protocol for you.
          In the TCP/IP Stack, TCP finally adds reliable communications ... well at least as long as the two communicating hosts are reachable (recall <code class="cmd">ping</code> and <code class="cmd">tracert</code>).
          In fact, reliable communications is the big difference between TCP, UDP, and the other networking protocols we have discussed.
        </p>
        <p>
          TCP is considered a <em>connection</em> oriented protocol; whereas UDP is connectionless.
          TCP communications are like communicating via the phone: you establish a connection, which requires knowing the phone number (remote IP Address and port), but after the connection is made, you communicate <em>through</em> the connection.
          As long as you don't hang up, you don't have to redial the number.
          You saw evidence of TCP connections in the <code class="cmd">netstat</code> code listings above.
          The ESTABLISHED state is the way that <code class="cmd">netstat</code> indicates that the TCP session is active, that a connection is established between the two processes on the two hosts.
        </p>
        <p>
          A TCP connection comes with services that other protocols don't provide, namely TCP provides reliable communications.
          TCP detects segments that are lost, and the sender will resend segments that the receiver did not receive.
          TCP also puts segments in the correct order.
          If a receiver receives TCP segments out of order, then the receiving host will use information in the TCP header to correctly order that segments.
          TCP also detects errors in the TCP header.
        </p>
        <p>
          So, what's the catch, why don't we use TCP for everything?
          Well, TCP is great, and many Application protocols do make use of the reliable connections that TCP provides, but at the cost of overhead.
          TCP can only provide those services at the cost of overhead for the sender and receiver.
          First off, the connection needs to be established before Application Layer messages can be sent.
          Before Application Layer data can be sent, the two hosts have to first establish the connection, in TCP this process is called a "handshake".
          In the simplest form of the handshake, a three way back and forth process must complete in order to establish the connection.
          For example, if Alice wants to talk to Bob via TCP.
          Alice sends a TCP synchronize request to Bob with some data to synchronize Bob to Alice (Part 1 of Handshake).
          Bob then replies with a combined TCP acknowledgment, acknowledge the synchronizing data from Alice, and TCP synchronize data for Bob's side of the connection (Part 2 of Handshake).
          Upon receiving Bob's TCP acknowledgment, Alice sends a TCP acknowledgment back to Bob acknowledging his synchronizing data (Part 3 of Handshake).
          Once the handshake is complete, then Application Layer data can be sent across the connection.
        </p>
        <p>
          There is also overhead in detecting, and recovering from dropped segments.
          Throughout Alice and Bob's communication there is a series of TCP acknowledgments being sent to indicate what segments have been received.
          If a certain amount of time goes by and Alice has not received an acknowledgment from Bob, then Alice assumes that the segment was dropped, and then resends the segment.
          There are two details to highlight with that.
          First, Alice has to keep a copy of all of the segments that she sent until Bob acknowledges them, and Bob is doing the same thing on his end; i.e. each host stores sent segments until the other host acknowledges the data.
          Again, that is overhead.
          Second, it took some amount of time for Alice to realize that Bob did not receive a segment.
          In practice, that time is low, on the order of 100s of milliseconds to seconds, but when compared to nanoseconds (<code>10<sup>-9</sup></code>), that is a long time.
        </p>
        <p>
          TCP also adds some other services that lower layer protocols do not.
          TCP provides flow control, flow control is a mechanism for the sending host to not overwhelm the resources of the receiving host.
          For example, flow control will limit the rate that data is sent to the receiver so as to not fill the receiver's resources, remember maintaining the connection requires CPU and RAM.
          TCP also provides congestion control, congestion control is a mechanism for the sending host to not overwhelm the network infrastructure.
          If Alice detects a number of segments not being received by Bob, then Alice will infer that some portion of the network infrastructure between Alice and Bob is overwhelmed, so Alice will reduce the rate in which she sends segments to Bob.
          Again, congestion control requires processing, CPU time, from the host.
          Both hosts are maintaining the connection state, managing flow control, and managing congestion control.
          So, the price of reliable communications is overhead; depending on the application that overhead may be worth it or not.
        </p>
        <div class="annotation">
          Use of <code class="cmd">nc</code> is restricted on USNA systems.
        </div>
        <p>
          <strong><code class="cmd">nk</code></strong>.
          netkitten (<code class="cmd">nk</code>) is a very simple but powerful, USNA tool based on netcat (<code class="cmd">nc</code>).
          <code class="cmd">nk</code> can be used in either server mode or client mode; i.e. <code class="cmd">nk</code> can listen for and accept an incoming phone call, or initiate a phone call.
          In the client mode of netkitten, you give it an IP Address (or symbolic name that it will resolve for you via DNS) and a port number, and whatever you type into after pressing enter gets sent to the given address and port using TCP over <a href="calendar.php-76.html?load=glossary#I">IPv4</a>.
          In the server mode of netkitten. you give the <code class="opt">-l</code> option (listen) and <code class="cmd">nk</code> then acts like a server, "listening" for a connection request.
          Accepting the first one it receives, then echoing whatever gets sent to it to the screen, and taking whatever gets typed on the screen and sending it to the client whose connection request it accepted.
          The diagram below illustrates what commands users on two hosts would have to give to make a TCP connection with netkitten.
        </p>
        <div class="table border">
          <div class="tableRow">
            <div class="tableCell border">
              <strong>Host 10.53.88.12</strong><br>
              (server: listens (-l) for connections on port 42123)
              <br>
              <code><span class="cmd">nk</span> <span class="opt">-l</span> <span class="arg">42123</span></code>
              <br>
              <br>
            </div>
            <div class="tableCell">
              <strong>Host 10.53.12.94</strong><br>
              (client: connects to 10.53.88.12 on port 42123)
              <br>
              <code><span class="cmd">nk</span> <span class="arg">10.53.88.12</span> <span class="arg">42123</span></code>
              <br>
              <br>
            </div>
          </div>
        </div>
        <p>
          <span class="note">The server command on Host 10.53.88.12 must be given first!
            Otherwise, when the client calls there's nobody home!</span>
          netkitten with the <code class="opt">-u</code> option (UDP) uses UDP instead of TCP.
          Since this is connectionless, the server version accepts datagrams from any and all who send them, rather than making a connection with one client.
          As another consequence, the UDP server doesn't exit just because one of the clients exits.
          With netkitten, we as users can act like Application Layer programs.
          Like most Application Layer programs, we require that the Transport Layer provide us with services, which means at a bare minimum that we decide whether we want UDP or TCP.
          There are lots of interesting demos and activities we can do that demonstrate how TCP and UDP work and how they differ from one another; especially if we are using protocols that are text oriented, easy for humans to create and read.
        </p>
      </div>
      <div>
        <h3>Network Address Translation (NAT)</h3>
        We've learned that each host on the Internet has an IP Address, and that network packets get routed based on the destination host's IP Address. In general, that's true. We've also learned that the IPv4 address space is essentially all allocated. There are plenty of IPv6 addresses, but we won't discuss the details of IPv6 in this course. However, there is another workaround for the limited IPv4 address space, called Network Address Translation, or <a href="calendar.php-76.html?load=glossary#N">NAT</a>. We discuss the operation of NAT in this course because it's very widely used, and because it has some security relevance.

        <ul>

          <li><strong><a href="calendar.php-76.html?load=glossary#P">Private IP Addresses</a></strong>. Although a network packet's destination IP Address determines how an intermediate host (like a <a href="calendar.php-76.html?load=glossary#R">router</a>) forwards the packet, it turns out there are some IP Addresses that are called "non-routable", or "private". Such IP Addresses are determined by convention, and include the following blocks:
          <ul>
            <li>10.0.0.0 - 10.255.255.255
            <li>172.16.0.0 - 172.31.255.255
            <li>192.168.0.0 - 192.168.255.255
          </li></ul>
          So what happens when a router out on the big public internet receives a packet whose destination IP Address is in one of these blocks? The router simply "drops" the packet. Why, then, would such addresses be useful?

          <li>Private IP Addresses are used in local networks, like the network in a house, or a network inside a school or business. Hosts within the local network are assigned a private IP Address. Routers inside the local network are configured to forward the packets around the internal network. Once a packet gets to the perimeter, or <a href="calendar.php-76.html?load=glossary#G">gateway</a>, of the local network, though, it must be assigned a "routable" IP Address (i.e., one not in the list above). These routable IP Addresses will usually come from your Internet Service Provider, or ISP.

          <li><strong>Why it helps</strong>. Thanks to private IP Addresses, local networks can contain thousands or even millions of hosts, even though an organization only has a much smaller number of "public" assigned IP Addresses through its ISP. When packets leave the local network and enter the public internet, they must receive a routable IP Address. What we need is a process by which the internal (non-routable, or private) IP Address can be mapped to its equivalent external, or public IP Address. This mapping has to remain consistent for "conversations" between hosts, like the TCP connections we discussed previously.

          <li><strong>Network Address Translation Mechanics</strong>. The way NAT works is as follows. When Host A (local) sends a packet to Site B (remote), the network packet is constructed with Site B's IP Address as the destination, and host A's address as the source. However, Host A's address is local-only. The packet goes through an intermediary host (a router or computer) at the local network perimeter, where NAT occurs. In NAT, Host A's IP Address is replaced with one of the local network's available public IP Addresses as the source. In addition, the source port number on the packet is reassigned to a number that uniquely identifies the connection with Host A. The mapping between Host A's local IP Address and port number (for this connection) and the source IP Address and port number in the packet are stored in a table by the intermediary. When packets return from Site B, the same mapping has to happen in reverse, since Site B does not know the real IP/port for Host A. This process works because there are a large number of port numbers (0-65535) we can use to fill the translation table.

          <br><br>For a demo, check out this <a href="calendar.php-92.html?key=1286d76efdf1c61f8e33e880353d746bd6f54528&type=resources&event=17">link</a>.

          <li><strong>See It On Your Laptop</strong>.
            <ul>
              <li>View your internal IP Address. Open a command <a href="calendar.php-76.html?load=glossary#S">shell</a> on Windows and issue the command <code><a href="calendar.php-76.html?load=glossary#I">ipconfig</a></code>.
              <li>Check your IPv4 address against the list above. Is it routable?
              <li>View what the Internet thinks your IP Address is. There are a few       websites that tell you what your IP Address appears to be. One example is <a href="../../index-18.htm">ipchicken.com</a>. Visit this web site and jot down the IP Address. Is it the same as what <code>ipconfig</code> told you?
            </li></ul>

          <center><img src="calendar.php-44.png?key=1e2a406decade28a64ddcad7cf56bb3ea5598986&type=class&event=20" style="height: 160pt"></center>

          <li><strong>Security Relevance</strong>. From a security standpoint, the key impact is that <u>potential attackers on the Internet can't easily scan private IP space for vulnerable hosts</u>. Any host with an IP Address that's public can be scanned, and some of the host's vulnerabilities potentially discovered. With NAT, your host is "hidden", in a way, behind the translation. Although NAT came about primarily to address the shortage of assignable public IPv4 addresses, one reason it remains popular is the security benefit. Even with the rise of IPv6 deployment all around the world, IPv4 with NAT remains a very popular implementation choice in commercial, educational, and home networks.

        </li></ul>
      </div>
    </div>

    <div id="refs">
    <h2>References</h2>
      <ol>
        <li>...</li>
      </ol>
    </div>
    <div class="footer">
      <hr>
      <div class="table">
        <div class="tableRow">
          <div class="tableCell noPrint">
            <a href="../../index.htm"><img class="badge" src="img/valid-html-blue.png" alt="Valid HTML"></a>
          </div>
          <!-- <DIV class="tableCell pubDomain">
            <A rel="license" href="http://creativecommons.org/publicdomain/mark/1.0/"><IMG class="badge" src="img/pub-domain.png" alt="Public Domain Mark"></A>
          </DIV> -->
        </div>
      </div>
    </div>
  </body>
</html>
</div> <!-- /container --></body></html>